# 0053. Maximum Subarray

## 题目描述

[0053. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

## 解法一（贪心算法）

### 思路

每一步都选择最佳方案，到最后就是全局最优方案。

**算法流程：**

遍历数组，在每个步骤中更新：

- 当前元素
- 当前元素位置的最大和 = max（当前元素，当前最大和+当前元素） 
- 迄今为止的最大和 = max（迄今最大和，当前最大和）

| 当前元素   | -2   | 1       | -3       | 4      | -1      | 2      | 1      | -5      | 4      |
| ---------- | ---- | ------- | -------- | ------ | ------- | ------ | ------ | ------- | ------ |
| 比较组     | /    | (1, -1) | (-3, -2) | (4, 2) | (-1, 3) | (2, 5) | (1, 6) | (-5, 1) | (4, 5) |
| 当前最大和 | -2   | 1       | -2       | 4      | 3       | 5      | 6      | 1       | 5      |
| 比较组     | /    | (-2, 1) | (1, -2)  | (1, 4) | (4, 3)  | (4, 5) | (5, 6) | (6, 1)  | (6, 5) |
| 迄今最大和 | -2   | 1       | 1        | 4      | 4       | 5      | 6      | 6       | 6      |

**算法复杂度：**

- 时间复杂度：O(N) -- 遍历一次数组
- 空间复杂度：O(1) -- 使用常数空间

### 题解

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 贪心算法
        re = cur = nums[0]
        for i in range(1, len(nums)):
            cur = max(nums[i], cur + nums[i])
            re = max(re, cur)
        return re
```

### 算法分析

#### 基本概念

贪心算法是指，在对问题求解时，总是做出**当前看来最好的选择**。不考虑整体最优，仅求局部最优解。

**贪心算法是一种特殊（最简单）的动态规划。**

**注意：**贪心策略必须具有**后无效性**，即某个状态之后的过程不会对前面的状态产生影响，只和当前状态有关。

#### 基本思路

1. 建立数学模型描述问题；
2. 把待求解的问题分解成若干个子问题；
3. 对每一个字问题求解，得到子问题的局部最优解；
4. 把子问题的局部最优解组合成问题的解。

#### 适用场景

局部最优策略能产生全局最优策略。

#### 实现框架

```c
从初始解出发;
while (朝总目标前进一步):{
    求当前局部最优解;
    更新全局最优解;
}
组成问题的可行解;
```

#### 本题分析

本题目的“求解和最大的连续数组”可以分解成连续的“当前元素能求得的最大和”（=当前元素开头or加上之前的连续元素）这样的小问题，只比较当前元素和当前元素+上一步的当前最大和，另设立一个变量单独计全局最优解，最后返回全局最优解即可。

## 解法二（动态规划 - Kadane 算法）

### 思路

原地更新数组为每个元素的当前最大和，用 `re` 记录循环每一步后的迄今为止的最大和。

**算法流程：**

遍历数组，在每个步骤中：

1. 更新当前元素；
2. 如果当前元素（最大和）大于 0：
   1. 累加当前最大和到下一个元素上得到下一个当前最大和；
3. 更新迄今为止的最大和。

| 当前元素   | -2   | 1    | -3   | 4    | -1   | 2    | 1    | -5   | 4    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 是否重开了 | /    | 是   | 否   | 是   | 否   | 否   | 否   | 否   | 否   |
| 当前最大和 | -2   | 1    | -2   | 4    | 3    | 5    | 6    | 1    | 5    |
| 迄今最大和 | -2   | 1    | 1    | 4    | 4    | 5    | 6    | 6    | 6    |

**算法复杂度：**

- 时间复杂度：O(N) -- 遍历一次数组
- 空间复杂度：O(1) -- 使用常数空间

### 题解

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 动态规划
        re = nums[0]
        for i in range(1, len(nums)):
            if (nums[i-1] > 0):
                nums[i] += nums[i-1]
            re = max(nums[i], re)
        return re
```

### 算法分析

#### 适用场景

在整个数组或者固定大小的滑动窗口中找到总和or最大值or最小值的问题可以使用动态规划（DP）方法在线性时间内解决。

适用于数组的两种标准 DP 方法：

1. 常数空间：沿数组移动方向在原数组上修改；
2. 线性空间：先正向移动，再反向移动，最后合并结果。

#### 求解框架

1. 状态（小规模的数学表示）
2. 状态转移方程（大问题如何转换为小问题）
3. 最小状态（最小规模的问题）
4. 终态（要求的返回值）

#### 算法对比

动态规划的性质：

1. 重叠子问题
2. 最优子结构

贪心算法：

1. 贪心选择性质（后无效性）
2. 最优子结构

由于动态规划问题不一定都是后无效的，所以上述适用于数组的方法中，需要分别向两个方向移动最后合并结果。

由上可看出贪心算法是一种特殊的动态规划，即问题是具有后无效性的。

#### 本题分析

将问题分解为“是否需要累加当前最大解”，即如果当前最大解小于 0，那么就没有考虑他的必要了，因为它至少会使后面的第一个元素对应的当前最大值变小。

#### 补充

求解问题时间复杂度比较高的，一般优先考虑如下几种算法：

- 分治法
- 递归法
- 贪心算法
- 动态规划
